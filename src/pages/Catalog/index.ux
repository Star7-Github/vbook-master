<template>
  <div class="wrapper">
    <div if="{{isLoading}}" class="loading">
      <text class="loading-text">åŠ è½½ä¸­...</text>
    </div>

    <!-- æ¨¡å¼1ï¼šåˆ†æ®µåˆ—è¡¨ -->
    <list
      title="true"
      scrollbar="true"
      class="range-list"
      if="{{!isLoading && showRanges}}">
      <list-item type="li" @click="handleBack">
        <div class="vwTitleWrapper">
          <div class="vwTitle">
            <vw-icon icon="arrow-left" [size]="sm"></vw-icon>
            <text>{{ titleText }}</text>
          </div>
        </div>
      </list-item>
      <list-item
        type="range"
        class="range-item"
        for="{{ranges}}"
        onclick="selectRange($idx)">
        <text class="range-text">{{ $item.label }}</text>
      </list-item>
    </list>

    <!-- æ¨¡å¼2ï¼šç« èŠ‚åˆ—è¡¨ -->
    <list
      title="true"
      scrollbar="true"
      class="chapter-list"
      if="{{!isLoading && !showRanges}}">
      <list-item type="li" @click="handleBack">
        <div class="vwTitleWrapper">
          <div class="vwTitle">
            <vw-icon icon="arrow-left" [size]="sm"></vw-icon>
            <text>{{ titleText }}</text>
          </div>
        </div>
      </list-item>
      <list-item
        type="chapter"
        class="chapter-item"
        for="{{chapters}}"
        onclick="selectChapter($item.index)">
        <text
          class="chapter-text {{ $item.index === currentIndex ? 'active' : '' }}">
          {{ $item.title }}
        </text>
        <!-- <text if="{{$item.cached}}" class="cached-tag">å·²ç¼“å­˜</text> -->
        <text class="cached-tag">å·²ç¼“å­˜</text>
      </list-item>
    </list>
  </div>
</template>

<script>
  import router from '@blueos.app.appmanager.router'
  import file from '@blueos.storage.file'
  import prompt from '@blueos.window.prompt'

  export default {
    data: {
      bookId: '',
      bookName: '',
      currentIndex: -1,

      totalCount: 0,
      pageSize: 50,

      isLoading: true,
      showRanges: true,
      ranges: [],
      chapters: [],
      allChaptersMeta: [], // Store chapter titles
    },
    computed: {
      titleText() {
        if (this.showRanges) {
          return 'ç›®å½•-é€‰æ‹©åˆ†é¡µ'
        }
        return 'ç›®å½•'
      },
    },
    onInit() {
      this.currentIndex = parseInt(this.currentIndex) || 0

      // ====== ðŸš€ MOCK MODE FOR UI DEBUGGING (å¼€å¯å³å¯) ======
      const USE_MOCK = false // è®¾ç½®ä¸º true å¯ç”¨æ¨¡æ‹Ÿæ•°æ®

      if (USE_MOCK) {
        this.bookId = 'mock-book-id'
        this.bookName = 'ã€è°ƒè¯•ç”¨ã€‘UIæµ‹è¯•ä¹¦'
        this.totalCount = 320 // æ€»ç« èŠ‚æ•°
        this.allChaptersMeta = Array.from(
          { length: this.totalCount },
          (_, index) => ({
            title: `ç¬¬ ${index + 1} ç«  æ ‡é¢˜`,
            index: index,
          })
        )

        // æ¨¡æ‹Ÿåˆ†æ®µåˆ—è¡¨
        if (this.totalCount > this.pageSize) {
          this.showRanges = true
          this.generateRanges()
        } else {
          this.showRanges = false
          this.loadChapters(0, this.totalCount)
        }

        this.isLoading = false
        return // è·³è¿‡çœŸå®žåŠ è½½é€»è¾‘
      }
      // ====== END MOCK MODE ======

      this.loadMeta()
    },
    async loadMeta() {
      const metaUri = `internal://files/book_${this.bookId}.json`
      try {
        const metaRes = await this.readText(metaUri)
        if (metaRes) {
          const meta = JSON.parse(metaRes)
          this.totalCount = parseInt(meta.chapterCount) || 0
          if (Array.isArray(meta.chapters)) {
            this.allChaptersMeta = meta.chapters
          }
        }
      } catch (e) {
        console.log('Read meta failed')
      }

      if (this.totalCount === 0) {
        this.isLoading = false
        prompt.showToast({ message: 'æš‚æ— ç›®å½•æ•°æ®' })
        return
      }

      // è¶…è¿‡ä¸€é¡µåˆ™æ˜¾ç¤ºåˆ†æ®µ
      if (this.totalCount > this.pageSize) {
        this.showRanges = true
        this.generateRanges()
      } else {
        this.showRanges = false
        this.loadChapters(0, this.totalCount)
      }
      this.isLoading = false
    },
    generateRanges() {
      const list = []
      const pageCount = Math.ceil(this.totalCount / this.pageSize)
      for (let i = 0; i < pageCount; i++) {
        const start = i * this.pageSize + 1
        const end = Math.min((i + 1) * this.pageSize, this.totalCount)
        list.push({
          label: `${start} - ${end} ç« `,
          startIndex: i * this.pageSize,
          count: end - i * this.pageSize,
        })
      }
      this.ranges = list
    },
    loadChapters(start, count) {
      const list = []
      for (let i = 0; i < count; i++) {
        const realIndex = start + i
        let title = `ç¬¬ ${realIndex + 1} ç« `
        if (this.allChaptersMeta && this.allChaptersMeta[realIndex]) {
          title = this.allChaptersMeta[realIndex].title || title
        }

        list.push({
          title: title,
          index: realIndex,
          cached: false,
        })
      }
      this.chapters = list
      this.checkCachedStatus(list)
    },
    async checkCachedStatus(currentList) {
      const dirPath = `internal://files/book_data_${this.bookId}`
      const results = await Promise.all(
        currentList.map((item) =>
          this.checkFileExists(`${dirPath}/${item.index}.txt`)
        )
      )

      // Update list with statuses
      const newList = currentList.map((item, i) => ({
        ...item,
        cached: results[i],
      }))
      this.chapters = newList
    },
    checkFileExists(uri) {
      return new Promise((r) =>
        file.access({ uri, success: () => r(true), fail: () => r(false) })
      )
    },
    selectRange(index) {
      const range = this.ranges[index]
      this.loadChapters(range.startIndex, range.count)
      this.showRanges = false
    },
    handleBack() {
      if (!this.showRanges && this.totalCount > this.pageSize) {
        // Return to range list
        this.showRanges = true
        this.chapters = []
      } else {
        router.back()
      }
    },
    readText(uri) {
      return new Promise((resolve) => {
        file.readText({
          uri,
          success: (data) => resolve(data.text),
          fail: () => resolve(null),
        })
      })
    },
    selectChapter(index) {
      router.replace({
        uri: '/pages/Reader',
        params: {
          bookId: this.bookId,
          bookName: this.bookName,
          chapterIndex: index,
          chapterCount: this.totalCount,
        },
      })
    },
  }
</script>

<style lang="less">
  .wrapper {
    flex-direction: column;
    justify-content: center;
    align-items: center;
  }
  .vwTitleWrapper {
    height: 80px;
    width: 100%;
    flex-direction: column;
    justify-content: flex-end;
    align-items: center;
    .vwTitle {
      align-items: center;
      justify-content: center;
      text {
        color: #ffffff;
        font-size: 40px;
        font-weight: bold;
        margin-right: 48px;
      }
    }
  }

  .loading {
    justify-content: center;
    align-items: center;
    height: 200px;
  }
  .loading-text {
    color: #fff;
  }

  .chapter-item {
    height: 100px;
    border-bottom-color: #333;
    border-bottom-width: 1px;
    padding: 0 20px;
  }

  .chapter-text {
    color: #fff;
    font-size: 30px;
    lines: 1;
    text-overflow: ellipsis;
    flex: 1;
  }

  .range-item {
    height: 100px;
    border-bottom-color: #333;
    border-bottom-width: 1px;
    justify-content: center;
    align-items: center;
    padding: 0 20px;
  }

  .range-text {
    color: #fff;
    font-size: 32px;
  }
  .cached-tag {
    font-size: 20px;
    color: #888;
    margin-left: 10px;
  }
</style>
