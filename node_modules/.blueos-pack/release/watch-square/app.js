let G={"@info":{styleObjectId:1411120752}};const K=G,C=$app_require$("@app-module/system.fetch"),j=$app_require$("@app-module/system.fetch"),A=$app_require$("@app-module/system.request"),m=$app_require$("@app-module/system.file"),g=$app_require$("@app-module/system.prompt"),L=$app_require$("@app-module/system.brightness"),h={},P="http://127.0.0.1:23101",D=5;function E(){return j&&typeof j.fetch=="function"?e=>j.fetch(e):typeof C=="function"?C:C&&typeof C.fetch=="function"?e=>C.fetch(e):null}function I(e){return new Promise(s=>{m.mkdir({uri:e,recursive:!0,success:()=>s({success:!0}),fail:(a,t)=>{m.access({uri:e,success:()=>s({success:!0}),fail:(n,i)=>s({success:!1,msg:t})})}})})}function H(e){return new Promise(s=>{m.list({uri:e,success:a=>s(a.fileList||[]),fail:()=>s([])})})}function V(e){return new Promise(s=>m.readText({uri:e,success:a=>s(a.text),fail:()=>s(null)}))}function Z(e){return new Promise(s=>m.delete({uri:e,success:()=>s(!0),fail:()=>s(!1)}))}function B(e,s,a){return new Promise(t=>m.writeText({uri:`${e}/${s}.txt`,text:a,success:()=>t(!0),fail:(n,i)=>{console.log(`[App] saveChapter fail ${s}: ${i}`),t(!1)}}))}function x(e){try{L.setKeepScreenOn({keepScreenOn:e,success:()=>console.log(`[App] KeepScreenOn: ${e}`),fail:(s,a)=>console.log(`[App] KeepScreenOn fail: ${a}`)})}catch(s){console.log(`[App] brightness error: ${s}`)}}function z(e){return new Promise(s=>{const a=E();if(!a){s(null);return}a({url:`${P}/api/novel/catalog?id=${e}`,method:"GET",responseType:"json",success:t=>{if(t.code===200||t.code===206){let n=t.data;if(typeof n=="string")try{n=JSON.parse(n)}catch{s(null);return}let i=null;n&&Array.isArray(n.chapters)?i=n.chapters:n&&n.data&&Array.isArray(n.data.chapters)&&(i=n.data.chapters),console.log(`[App] fetchCatalog: got ${i?i.length:0} chapters`),s(i)}else console.log(`[App] fetchCatalog: unexpected code ${t.code}`),s(null)},fail:(t,n)=>{console.log(`[App] fetchCatalog fail: ${n}`),s(null)}})})}function Q(e,s,a){return new Promise(t=>{if(!A||typeof A.download!="function"){t(null);return}const n=`internal://files/_temp_batch_${e}.json`,i=`${P}/api/novel/chapters?id=${e}&from=${s}&to=${a}&dl=1`;A.download({url:i,filename:n,success:r=>{const u=r.token;A.onDownloadComplete({token:u,success:()=>{m.access({uri:n,success:()=>t(n),fail:()=>{console.log("[App] Batch temp file not found"),t(null)}})},fail:(d,w)=>{console.log(`[App] Batch download complete fail: ${w}`),t(null)}})},fail:(r,u)=>{console.log(`[App] Batch download fail: ${u}`),t(null)}})})}async function W(e,s,a,t){let n=await V(e);if(!n)return console.log("[App] Failed to read batch temp file"),{saved:0,failed:a.length};let i=null;try{i=JSON.parse(n)}catch(d){return console.log(`[App] Failed to parse batch JSON: ${d}`),{saved:0,failed:a.length}}n=null;let r=0,u=0;for(const d of a){const w=String(d);if(i[w]){const b=await B(s,d,i[w]);i[w]=null,b?(t.add(`${d}.txt`),r++):u++,await new Promise($=>setTimeout($,50))}else u++}return i=null,{saved:r,failed:u}}function X(e,s,a){return new Promise(t=>{const n=E();if(!n){t(null);return}n({url:`${P}/api/novel/chapters?id=${e}&from=${s}&to=${a}`,method:"GET",responseType:"json",success:i=>{if(i.code===200||i.code===206){let r=i.data;if(typeof r=="string")try{r=JSON.parse(r)}catch{t(null);return}t(r)}else t(null)},fail:()=>t(null)})})}function Y(e,s){return new Promise(a=>{const t=E();if(!t){a(null);return}t({url:`${P}/api/novel/chapter?id=${e}&index=${s}`,method:"GET",responseType:"text",success:n=>{n.code===200||n.code===206?a(n.data):a(null)},fail:()=>a(null)})})}async function v(e){const s=e.id,a=parseInt(e.chapterCount)||0,t=h[s],n=await z(s),i=Array.isArray(n)?n.map(o=>({title:o.title||""})):[],r={id:e.id,name:e.name,chapterCount:e.chapterCount,currentChapter:0,isOffline:!1,chapters:i},u=`book_${e.id}.json`;await new Promise(o=>{m.writeText({uri:`internal://files/${u}`,text:JSON.stringify(r),success:()=>{console.log(`[App] Meta saved with ${i.length} chapter titles`),o(!0)},fail:(l,f)=>{console.log(`[App] Meta save fail: ${f}`),o(!1)}})});const d=`internal://files/book_data_${e.id}`;if(!(await I(d)).success){g.showToast({message:"目录创建失败"}),t.status="error",x(!1);return}const b=await H(d),$=new Set;for(const o of b){let l=o.filename;if(!l&&o.uri){const f=o.uri.split("/");l=f[f.length-1]}$.add(l)}let M=0;for(let o=0;o<a;o++)$.has(`${o}.txt`)||M++;if(M===0){t.progress=100,t.status="done",x(!1),r.isOffline=!0,await new Promise(o=>{m.writeText({uri:`internal://files/${u}`,text:JSON.stringify(r),success:()=>o(!0),fail:()=>o(!1)})}),g.showToast({message:`${e.name} 已完整`});return}console.log(`[App] Need to download ${M}/${a} chapters`),x(!0);const U=A&&typeof A.download=="function";let F=0,O=0,_=0;if(U){t.phase="download",console.log("[App] Using request.download batch mode");let o=0;for(;o<a&&t.status==="running";){if(O>3){console.log("[App] Too many batch fails, fallback to fetch"),g.showToast({message:"切换到备用下载方式"});break}const l=Math.min(o+D-1,a-1),f=[];for(let p=o;p<=l;p++)$.has(`${p}.txt`)||f.push(p);if(f.length===0){_=l+1,t.progress=Math.floor(_/a*100),o=l+1;continue}const N=f[0],T=f[f.length-1],c=await Q(s,N,T);if(c){const p=await W(c,d,f,$);await Z(c),p.saved>0?O=0:O++,F+=p.failed,await new Promise(k=>setTimeout(k,100))}else O++,F+=f.length;_=l+1,t.progress=Math.floor(_/a*100),o=l+1}if(O<=3&&t.status==="running"){t.status="done",x(!1),F===0?(r.isOffline=!0,await new Promise(l=>{m.writeText({uri:`internal://files/${u}`,text:JSON.stringify(r),success:()=>{console.log("[App] Final meta saved: isOffline=true"),l(!0)},fail:()=>l(!1)})}),g.showToast({message:`${e.name} 下载完成`})):g.showToast({message:`${e.name} 缺${F}章，点下载可补全`});return}}t.phase="batch",console.log("[App] Using fetch batch mode");let S=0,q=0,y=0;for(;y<a&&t.status==="running";){if(S>50){g.showToast({message:"失败过多，请稍后重试"}),t.status="error",x(!1);break}const o=Math.min(y+D-1,a-1),l=[];for(let c=y;c<=o;c++)$.has(`${c}.txt`)||l.push(c);if(l.length===0){y=o+1,t.progress=Math.floor(y/a*100);continue}const f=l[0],N=l[l.length-1],T=await X(s,f,N);if(T&&typeof T=="object")for(const c of l){const p=String(c);T[p]?await B(d,c,T[p])&&($.add(`${c}.txt`),S=0):(q++,S++),t.progress=Math.floor((c+1)/a*100)}else for(const c of l){if(t.status!=="running")break;const p=await Y(s,c);p?(await B(d,c,p),$.add(`${c}.txt`),S=0):(S++,q++),t.progress=Math.floor((c+1)/a*100)}y=o+1}t.status="done",x(!1);const J=F+q;J===0?(r.isOffline=!0,await new Promise(o=>{m.writeText({uri:`internal://files/${u}`,text:JSON.stringify(r),success:()=>{console.log("[App] Final meta saved: isOffline=true"),o(!0)},fail:()=>o(!1)})}),g.showToast({message:`${e.name} 下载完成`})):g.showToast({message:`${e.name} 缺${J}章，点下载可补全`})}const R={onCreate(){},start(e){if(h[e.id]&&h[e.id].status==="running"){g.showToast({message:"正在后台下载中..."});return}h[e.id]={id:e.id,progress:0,status:"running",phase:"download",name:e.name},g.showToast({message:`开始下载: ${e.name}`}),v(e)},getTask(e){return h[e]},getRunningTask(){for(const e in h)if(h[e].status==="running")return h[e];return null},clearTask(e){h[e]&&(h[e].status="cancelled",delete h[e],console.log(`[App] Cleared task for book ${e}`))}};$app_define$("@app-component/app",[],function(e,s,a){a.exports=R.default||R,a.exports.style=K});$app_bootstrap$("@app-application/app");
